<!DOCTYPE html> <html> <head> <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"> <meta charset="utf-8"> <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <title>Sparse factorization of dense matrices | Florian Schäfer</title> <meta name="author" content="Florian Schäfer"> <meta name="description" content="Fade-out instead of fill-in"> <link href="https://cdn.jsdelivr.net/npm/bootstrap@4.6.1/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha256-DF7Zhf293AJxJNTmh5zhoYYIMs2oXitRfBjY+9L//AY=" crossorigin="anonymous"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/css/mdb.min.css" integrity="sha256-jpjYvU3G3N6nrrBwXJoVEYI/0zw8htfFnhT9ljN3JJw=" crossorigin="anonymous"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.4/css/all.min.css" integrity="sha256-mUZM63G8m73Mcidfrv5E+Y61y7a12O5mW4ezU3bxqW4=" crossorigin="anonymous"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/academicons@1.9.1/css/academicons.min.css" integrity="sha256-i1+4qU2G2860dGGIOJscdC30s9beBXjFfzjWLjBRsBg=" crossorigin="anonymous"> <link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Roboto+Slab:100,300,400,500,700|Material+Icons"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/jwarby/jekyll-pygments-themes@master/github.css" media="" id="highlight_theme_light"> <link rel="shortcut icon" href="data:image/svg+xml,&lt;svg%20xmlns=%22http://www.w3.org/2000/svg%22%20viewBox=%220%200%20100%20100%22&gt;&lt;text%20y=%22.9em%22%20font-size=%2290%22&gt;%F0%9F%93%9C&lt;/text&gt;&lt;/svg&gt;"> <link rel="stylesheet" href="/assets/css/main.css"> <link rel="canonical" href="https://f-t-s.github.io/projects/cholesky/"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/jwarby/jekyll-pygments-themes@master/native.css" media="none" id="highlight_theme_dark"> <script src="/assets/js/theme.js"></script> <script src="/assets/js/dark_mode.js"></script> <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script> <script type="text/javascript">window.MathJax={tex:{tags:"ams"}};</script> <script defer type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3.2.0/es5/tex-mml-chtml.js"></script> <script defer src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script> <script src="/assets/js/distillpub/template.v2.js"></script> <script src="/assets/js/distillpub/transforms.v2.js"></script> <script src="/assets/js/distillpub/overrides.js"></script> </head> <body> <d-front-matter> <script async type="text/json">{
      "title": "Sparse factorization of dense matrices",
      "description": "Fade-out instead of fill-in",
      <!-- "published": "October 21, 2024",
      "authors": [
        
      ],-->
      "katex": {
        "delimiters": [
          {
            "left": "$",
            "right": "$",
            "display": false
          },
          {
            "left": "$$",
            "right": "$$",
            "display": true
          }
        ]
      }
    }</script> </d-front-matter> <header> <nav id="navbar" class="navbar navbar-light navbar-expand-sm fixed-top"> <div class="container"> <a class="navbar-brand title font-weight-lighter" href="/"><span class="font-weight-bold">Florian </span>Schäfer</a> <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation"> <span class="sr-only">Toggle navigation</span> <span class="icon-bar top-bar"></span> <span class="icon-bar middle-bar"></span> <span class="icon-bar bottom-bar"></span> </button> <div class="collapse navbar-collapse text-right" id="navbarNav"> <ul class="navbar-nav ml-auto flex-nowrap"> <li class="nav-item "> <a class="nav-link" href="/">about</a> </li> <li class="nav-item "> <a class="nav-link" href="/people/">people</a> </li> <li class="nav-item "> <a class="nav-link" href="/projects/">projects</a> </li> <li class="nav-item "> <a class="nav-link" href="/publications/">publications</a> </li> <li class="nav-item "> <a class="nav-link" href="/teaching/">teaching</a> </li> <li class="nav-item "> <a class="nav-link" href="/cv/">cv</a> </li> <li class="toggle-container"> <button id="light-toggle" title="Change theme"> <i class="fas fa-moon"></i> <i class="fas fa-sun"></i> </button> </li> </ul> </div> </div> </nav> <progress id="progress" value="0"> <div class="progress-container"> <span class="progress-bar"></span> </div> </progress> </header> <div class="post distill"> <d-title> <h1>Sparse factorization of dense matrices</h1> <p>Fade-out instead of fill-in</p> </d-title> <d-byline></d-byline> <d-article> <h3 id="introduction">Introduction</h3> <p><em>This post summarizes joint work with <a href="http://www.tjsullivan.org.uk/" rel="external nofollow noopener" target="_blank">Tim</a> and <a href="http://users.cms.caltech.edu/~owhadi/index.htm" rel="external nofollow noopener" target="_blank">Houman</a> on the sparse Cholesky factorization of dense kernel matrices. In the interest of conciseness, I will defer to our <a href="https://arxiv.org/abs/1706.02205" rel="external nofollow noopener" target="_blank">paper</a> for discussions of related work and technical details.</em></p> <h4 id="kernel-matrices">Kernel Matrices</h4> <p>Positive definite kernel matrices of the form</p> \[\Theta_{ij} := \mathcal{G}\left(x_i, x_j\right)\] <p>play an important role in many parts of computational mathematics. They arise as covariance matrices of Gaussian processes in statistics and as discretized solution operators of partial differential equations in computational engineering. By means of the <a href="https://en.wikipedia.org/wiki/Kernel_method#Mathematics:_the_kernel_trick" rel="external nofollow noopener" target="_blank">kernel trick</a>, they allow machine learning algorithms to employ infinite dimensional features maps.</p> <h4 id="finitely-smooth-gaussian-processes">(Finitely) smooth Gaussian processes</h4> <p>We focus on covariance matrices of finitely smooth Gaussian processes or, equivalently, the solution operators of elliptic partial differential equations (PDEs). Qualitatively, these kernels assign larger values to pairs of nearby points and smaller values to pairs of distant points. This means that if we observe a smooth random process to be positive in a point \(x\), we will strongly expect it to be positive at a nearby point \(y\). If this is all we know, we also tend to believe that values at a more distant point \(z\) are positive, but we will be less confident in this belief. A popular class of such covariance functions is given by the <a href="https://en.wikipedia.org/wiki/Mat%C3%A9rn_covariance_function" rel="external nofollow noopener" target="_blank">Matérn family</a>.</p> <div class="row"> <div class="col"> <img class="img-fluid" src="/assets/img/cholesky/correlation.png" alt="" title="The correlation is positive and falls of with distance"> </div> <div class="col"> <img class="img-fluid" src="/assets/gif/cholesky/confidence.gif" alt="" title="Nearby points have similar values, values of more distant points become less dependent."> </div> </div> <div class="caption"> On the left we show the correlation between values at \( {\color{#A1BDC7} x } \) and other points under a Matérn model. On the right we show different realizations of the assoe ciated Gaussian process, conditioned to be one in \( {\color{#A1BDC7} x } \). The values at the nearby point \( {\color{#D98C21} y} \) are close to one. The values at the distant point \( {\color{#B8420F} z} \) are positive on average, but vary wildly. </div> <h4 id="the-cubic-bottleneck">The cubic bottleneck</h4> <p>In most applications, we need to apply a kernel matrix to a vector (\(v \mapsto \Theta v\)), apply its inverse to a vector (\(v \mapsto \Theta^{-1}v\)), or compute its logdeterminant. However, \(\Theta\) is usually <em>dense</em>, meaning that most of its entries are not small enough to be ignored. When using \(N\) points of data, even storing the matrix has complexity \(N^2\) and inverting it using a dense Cholesky factorization has complexity \(N^3\). This becomes the major computational bottleneck in contemporary problems featuring large amounts of data and complex physical models.</p> <h3 id="our-method">Our method</h3> <p>We improve the state of the art computational efficiency by a simple three step algorithm.</p> <ol> <li> <p>Reorder the degrees of freedom, and therefore the rows and columns of \(\Theta\).</p> </li> <li> <p>Compute the entries of \(\Theta\) on a sparsity set \(\mathcal{S}\) of just near-linearly many entries.</p> </li> <li> <p>Compute the Cholesky factorization \(\Theta\), ignoring any operations outside of \(\mathcal{S}\).</p> </li> </ol> <h4 id="picking-the-ordering">Picking the ordering</h4> <p>We order the datapoints from coarse to fine according to the <em>maximin ordering</em>. This means that we successively pick the point that is furthest away from the points that we have picked already, starting with an arbitrary point.</p> <h4 id="selecting-the-sparsity-set">Selecting the sparsity set</h4> <p>We denote as \(\ell_i\) the distance that the \(i\)-th point of the maximin ordering had to the points picked before. We choose a tuning parameter \(\rho\) and let \(x_i\) interact with all points later in the ordering that have a distance at most \(\rho \ell_i\). This means that we add an element \((i,j)\) to the sparsity set \(S_\rho\) if \(i \geq j\) and \(\mathrm{dist}(x_i, x_j) \leq \rho \ell_i\).</p> <h4 id="incomplete-cholesky-factorization">Incomplete Cholesky factorization</h4> <p>The <a href="https://en.wikipedia.org/wiki/Cholesky_decomposition" rel="external nofollow noopener" target="_blank">Cholesky factorization</a> takes in the lower triangular part of a Matrix \(\Theta\) and, by updates of the form \(\Theta_{ki} \leftarrow \Theta_{kj} - \Theta_{ki} \Theta_{ji} / \Theta_{ii}\), transforms it into a lower triangular matrix \(L\) that satisfies \(L L^{\top} = \Theta\). We exploit the sparsity of \(S_\rho\) by instead computing the <a href="https://en.wikipedia.org/wiki/Incomplete_Cholesky_factorization" rel="external nofollow noopener" target="_blank">incomplete Cholesky factorization</a> that treats entries outside of \(S_\rho\) as zero and skips updates involving them.</p> <div class="row"> <div class="col-sm-8 mt-3 mt-md-0"> <img class="img-fluid" src="/assets/gif/cholesky/sortsparse_combined.gif" alt="" title="We select an ordering and sparsity pattern"> </div> <div class="col-sm-4 mt-3 mt-md-0"> <img class="img-fluid" src="/assets/gif/cholesky/ichol.gif" alt="" title="and then compute the incomplete Cholesky factorization."> </div> </div> <div class="caption"> The maximin ordering successively selects the <span style="color: rgb(72%,26%,6%);">point </span>\( {\color{#B8420F} x_k} \) that has <span style="color: rgb(72%,26%,6%);">maximal distance </span> \( {\color{#B8420F} \ell_k} \) from the <span style="color: rgb(63%,74%,78%);">points that were selected so far</span> (left). We add those entries corresponding to interactions of \( {\color{#B8420F}x_k} \) with <span style="color: rgb(85%,55%,13%);">points within radius </span> \( {\color{#D98C21}\rho \ell_k} \) to the <span style="color: rgb(63%,74%,78%);"> sparsity pattern </span> \( {\color{#A1BDC7} S_\rho} \) (middle). We then compute the incomplete Cholesky factorization, meaning that we skip the update \( {\color{#A1BDC7}\Theta_{kj}} \leftarrow {\color{#A1BDC7} \Theta_{kj}} - {\color{#D98C21} \Theta_{ki} \Theta_{ji}} / {\color{#B8420F}\Theta_{ii}} \) whenever it involves entries outside the <span style="color:rgb(69%,67%,66%);"> sparsity pattern</span> (right). </div> <h4 id="sparsity-allows-for-fast-computation">Sparsity allows for fast computation</h4> <p>If the set \(\{x_i\}_{1 \leq i \leq N}\) is \(d\)-dimensional, this can be done in time \(\mathcal{O}\left(N \log^{2}\left(N\right) \rho^{2d} \right)\) and space \(\mathcal{O}\left(N \log^{}\left(N\right) \rho^{d} \right)\). This yields a major improvement over the <em>naive</em> complexity \(\mathcal{O}(N^3)\).</p> <h3 id="it-works-but-why">It works! But why?</h3> <p>The algorithm described above produces a sparse lower triangular matrix \(L\) that approximates the kernel matrix as \(L L^{\top} \approx \Theta\). Due to being triangular, \(L\) and \(L^{\top}\) can be inverted efficiently using <a href="https://en.wikipedia.org/wiki/Triangular_matrix#Forward_and_back_substitution" rel="external nofollow noopener" target="_blank">forward and back substitution</a> and their determinant the product of their diagonal entries.</p> <h4 id="exponential-accuracy">Exponential accuracy</h4> <p>But how accurate is \(L L^{\top} \approx \Theta\). We have performed two very aggressive approximations: First we have set all but \(\mathcal{O}\left(N \log\left(N\right) \rho^{d} \right)\) many entries of the dense \(N \times N\) matrix \(\Theta\) to zero, and then we have skipped all but \(\mathcal{O}\left(N \log^{2}\left(N\right) \rho^{2d} \right)\) operations of its Cholesky factorization. By itself, either of these approximations results in a <em>horrible</em> approximation error. But in combination they provide an accurate approximation. In fact, we prove that if \(\Theta\) is the Green’s matrix of an elliptic boundary value problem and \(\rho \approx \log(N)\), we get \(\log\left(\left\|\Theta - L L^{\top}\right\| \right) \lesssim -\rho\). The error decays <em>exponentially</em> in \(\rho\)!</p> <h4 id="fade-out-instead-of-fill-in">Fade-out instead of fill-in</h4> <p>The Cholesky factorization of sparse matrices is a classical field in numerical analysis. In this case, the main difficulty is dealing with <em>fill-in</em> that leads to Cholesky factors that are much denser than the input matrix. In contrast, we observe that many <em>dense</em> kernel matrices exhibit <em>fade-out</em>, leading to almost sparse Cholesky factors.</p> <h4 id="gaussian-elimination-and-gaussian-processes">Gaussian elimination and Gaussian processes</h4> <p>The <em>fade-out</em> phenomenon has not been observed before but from a probabilistic point of view it is not surprising. Cholesky factorization can be interpreted as recursive application of</p> <div class="l-page-outset"> $$ \begin{pmatrix} \Theta_{1,1} &amp; \Theta _{1,2} \\ \Theta_{2,1} &amp; \Theta_{2,2} \end{pmatrix} = \begin{pmatrix} \mathrm{Id} &amp; 0 \\ {\color{#D98C21} \Theta_{2,1}\left(\Theta_{1, 1}\right)^{-1}} &amp; \mathrm{Id} \end{pmatrix} \begin{pmatrix} \Theta_{1, 1} &amp; 0 \\ 0 &amp; {\color{#A1BDC7} \Theta_{2,2} - \Theta_{2,1} \left(\Theta_{1,1}\right)^{-1} \Theta_{1,2}} \end{pmatrix} \begin{pmatrix} \mathrm{Id} &amp; {\color{#D98C21} \left(\Theta_{1, 1}\right)^{-1}\Theta_{1,2}}\\ 0 &amp; \mathrm{Id} \end{pmatrix}. $$ </div> <p>For \((X_1, X_2) \sim \mathcal{N}\left(0, \Theta\right)\) we have</p> \[\mathbb{E}\left[ X_2 \middle| X_1 = a \right] = {\color{#D98C21}\Theta_{2,1}\left(\Theta_{1, 1}\right)^{-1}} a \quad \mathrm{and} \quad\mathrm{Cov}\left[X_2 \middle| X_1 \right] = {\color{#A1BDC7}\Theta_{2,2} - \Theta_{2,1} \left(\Theta_{1,1}\right)^{-1} \Theta_{1,2}}\] <p>meaning that Cholesky factorization amounts to iteratively conditioning a Gaussian process. In particular, conditional independence in the Gaussian process \(X\) directly corresponds to sparsity in the Cholesky factors of \(\Theta\). There are many interesting densely correlated stochastic processes that feature conditional independence. Therefore, many interesting dense matrices are subject to fade-out.</p> <div class="row"> <div class="col"> <img class="img-fluid" src="/assets/gif/cholesky/fill-in_resized.gif" alt="" title="Many sparse matrices exhibit fill-in, leading to dense Cholesky factors"> </div> <div class="col"> <img class="img-fluid" src="/assets/gif/cholesky/fade-out_resized.gif" alt="" title="In contrast, we show that some dense matrices feature fade-out, leading to sparse Cholesky factors"> </div> <div class="col"> <img class="img-fluid" src="/assets/gif/cholesky/screening_resized.gif" alt="" title="and then compute the incomplete Cholesky factorization."> </div> </div> <div class="caption"> It is well known that many sparse matrices exhibit <em>fill-in</em>, leading to substantially dense Cholesky factors. (left) In contrast, we observe that the dense covariance matrices of smooth Gaussian processes exhibit <em>fade-out</em>, leading to almost sparse Cholesky factors. (center, magnitude of entries on \( \log_{10} \) scale). This behavior is due to the <em> screening effect</em>, whereby the <span style="color: rgb(85%,55%,13%);">conditional correlation</span> of a given <span style="color: rgb(72%,26%,6%);"> point </span> will localize, as we condition on <span style="color: rgb(63%,74%,78%);"> nearby points</span> (right). </div> <h4 id="the-screening-effect">The screening effect</h4> <p>In the case of covariance matrices of finitely smooth Gaussian processes, the sparsity of their Cholesky factors is predicted by the <em>screening effect</em>. We have seen in the introduction that the values at a point \(y\) close to \(x\) are much more informative of the value at \(x\) than those at a distant point \(z\). This means that the value at \(x\) is almost independent of that at \(z\), conditional on the value at \(y\). Under the elimination ordering chosen in our method, the first \(k\) points cover the data set up to a distance \(\ell_k\). Conditional on the values at these points, the correlation length is of the order \(\ell_k\), which informs our choice of sparsity pattern \(S_\rho\).</p> <h3 id="wrapping-up">Wrapping up</h3> <p>Cholesky factorization and the numerical analysis of elliptic partial differential equations are classical field of applied mathematics. Nevertheless, the probabilistic intuition described above leads to a <strong>simple algorithm</strong> that <strong>improves the state of the art</strong> computational complexity on a large class of problems. In our <a href="https://arxiv.org/abs/1706.02205" rel="external nofollow noopener" target="_blank">paper</a>, we draw connections to operator adapted wavelets and numerical homogenization that allow us to prove these results rigorously. There, we also show that incomplete Cholesky factorization in the reverse maximin ordering allows to efficiently invert the sparse stiffness matrices of elliptic PDEs. Just like in the case of Green’s matrices, this simple algorithm improves upon the state of the art computational complexity for general elliptic PDEs. Furthermore, our methods allow for the efficient computation of near optimal low-rank approximations, corresponding to the principal component analysis (in the Green’s matrix case) or homogenization (in the stiffness matrix case). In recent <a href="https://arxiv.org/abs/2004.14455" rel="external nofollow noopener" target="_blank">follow-up work</a>, we extend these ideas to provide an embarassingly parallel algorithm with even better computational complexity.</p> </d-article> <d-appendix> <d-footnote-list></d-footnote-list> <d-citation-list></d-citation-list> </d-appendix> <d-bibliography src="/assets/bibliography/"></d-bibliography> </div> <footer class="fixed-bottom"> <div class="container mt-0"> © Copyright 2024 Florian Schäfer. Powered by <a href="https://jekyllrb.com/" target="_blank" rel="external nofollow noopener">Jekyll</a> with <a href="https://github.com/alshedivat/al-folio" rel="external nofollow noopener" target="_blank">al-folio</a> theme. Hosted by <a href="https://pages.github.com/" target="_blank" rel="external nofollow noopener">GitHub Pages</a>. </div> </footer> <script src="https://cdn.jsdelivr.net/npm/bootstrap@4.6.1/dist/js/bootstrap.bundle.min.js" integrity="sha256-fgLAgv7fyCGopR/gBNq2iW3ZKIdqIcyshnUULC4vex8=" crossorigin="anonymous"></script> <script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/js/mdb.min.js" integrity="sha256-NdbiivsvWt7VYCt6hYNT3h/th9vSTL4EDWeGs5SN3DA=" crossorigin="anonymous"></script> <script type="text/javascript">function progressBarSetup(){"max"in document.createElement("progress")?(initializeProgressElement(),$(document).on("scroll",function(){progressBar.attr({value:getCurrentScrollPosition()})}),$(window).on("resize",initializeProgressElement)):(resizeProgressBar(),$(document).on("scroll",resizeProgressBar),$(window).on("resize",resizeProgressBar))}function getCurrentScrollPosition(){return $(window).scrollTop()}function initializeProgressElement(){let e=$("#navbar").outerHeight(!0);$("body").css({"padding-top":e}),$("progress-container").css({"padding-top":e}),progressBar.css({top:e}),progressBar.attr({max:getDistanceToScroll(),value:getCurrentScrollPosition()})}function getDistanceToScroll(){return $(document).height()-$(window).height()}function resizeProgressBar(){progressBar.css({width:getWidthPercentage()+"%"})}function getWidthPercentage(){return getCurrentScrollPosition()/getDistanceToScroll()*100}const progressBar=$("#progress");window.onload=function(){setTimeout(progressBarSetup,50)};</script> </body> </html>